<textarea name="text" cols="25" rows="5">
    cg1
#include <GL/glut.h>
#include <stdio.h>
int x1,x2,y3, y2;

void myInit()
{
    glClear(GL_COLOR_BUFFER_BIT);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glMatrixMode(GL_PROJECTION);
    gluOrtho2D(0, 500, 0, 500);
}

void draw_pixel(int x, int y)
{
    glBegin(GL_POINTS);
    glVertex2i(x, y);
    glEnd();
}

void draw_line(int x1, int x2, int y3, int y2)
{
    int dx, dy, i, e, x, y, incx, incy, inc1, inc2;
    dx = x2-x1;
    dy = y2-y3;
    if (dx < 0)
        dx = -dx;
    if (dy < 0)
        dy = -dy;
    
    incx = 1;
    if (x2 < x1)
        incx = -1;
    
    incy = 1;
    if (y2 < y3)
        incy = -1;
    
    x = x1; y = y3;

    if (dx > dy) 
    {
        draw_pixel(x, y);
        e = 2 * dy-dx;
        inc1 = 2*(dy-dx);
        inc2 = 2*dy;
        for (i=0; i<dx; i++) 
        {
            if (e >= 0) 
            {
                y += incy;
                e += inc1;
            }
            else
                e += inc2;
            x += incx;
            draw_pixel(x, y);
        }
    }
    else
    {
        draw_pixel(x, y);
        e = 2*dx-dy;
        inc1 = 2*(dx-dy);
        inc2 = 2*dx;
        for (i=0; i<dy; i++)
        {
            if (e >= 0)
            {
                x += incx;
                e += inc1;
            }
            else
                e += inc2;
            y += incy;
            draw_pixel(x, y);
        }
    }
}

void myDisplay() 
{
    draw_line(x1, x2, y3, y3);
    glFlush();
}

int main(int argc, char **argv)
{
    printf( "Enter (x1, y3, x2, y2)\n");
    scanf("%d %d %d %d", &x1, &y3, &x2, &y3);
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(500, 500);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("Bresenham's Line Drawing");
    myInit();
    glutDisplayFunc(myDisplay);
    glutMainLoop();
    return 0;
}

cg2
#include<gl/glut.h> 
#include<stdio.h>
int x,y; int rFlag=0; 
void draw_pixel(float x1,float y1) 
{ 
glColor3f(0.0,0.0,1.0); 
glPointSize(5.0); 
glBegin(GL_POINTS); 
glVertex2f(x1,y1); 
glEnd(); 
} 
void triangle() 
{ 
glColor3f(1.0,0.0,0.0); 
glBegin(GL_POLYGON); 
glVertex2f(100,100); 
glVertex2f(250,400); 
glVertex2f(400,100); 
glEnd(); 
} 
float th=0.0; 
float trX=0.0,trY=0.0; 
void display() 
{ 
glClear(GL_COLOR_BUFFER_BIT); 
glLoadIdentity(); 
if(rFlag==1) //Rotate Around origin 
{ 
trX=0.0;
 trY=0.0; 
th+=0.1; 
draw_pixel(0.0,0.0); 
} 
if(rFlag==2) //Rotate Around Fixed Point 
{
 trX=x;
 trY=y; 
th+=0.1; 
draw_pixel(x,y); 
} 
glTranslatef(trX,trY,0.0); 
glRotatef(th,0.0,0.0,1.0); 
glTranslatef(-trX,-trY,0.0); 
triangle(); 
glutPostRedisplay(); 
glutSwapBuffers(); 
} 
void myInit() 
{ 
glClearColor(0.0,0.0,0.0,1.0); 
glMatrixMode(GL_PROJECTION);
glLoadIdentity(); 
gluOrtho2D(-500.0, 500.0, -500.0, 500.0); 
glMatrixMode(GL_MODELVIEW); 
} 
void rotateMenu (int option) 
{ 
if(option==1) rFlag=1; 
if(option==2) rFlag=2; 
if(option==3) rFlag=3; 
} 
void main(int argc, char **argv) 
{
 printf( "Enter Fixed Points (x,y) for Roration: \n"); 
scanf("%d %d", &x, &y); 
glutInit(&argc, argv); 
glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB); 
glutInitWindowSize(500, 500); 
glutInitWindowPosition(0, 0); 
glutCreateWindow("Create and Rotate Triangle");
 myInit(); 
glutDisplayFunc(display); 
glutCreateMenu(rotateMenu); 
glutAddMenuEntry("Rotate around ORIGIN",1); 
glutAddMenuEntry("Rotate around FIXED POINT",2); 
glutAddMenuEntry("Stop Rotation",3); 
glutAttachMenu(GLUT_RIGHT_BUTTON); 
glutMainLoop(); 
}


cg3
#include<stdlib.h>
#include<GL/glut.h>

GLfloat vertices[]={-1.0,-1.0,-1.0,1.0,-1.0,-1.0,1.0,
                    1.0,-1.0,-1.0,1.0,-1.0,-1.0,-1.0,1.0,
                    1.0,-1.0,1.0,1.0,1.0,1.0,-1.0,1.0,1.0};

GLfloat colors[] = {0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,
                    0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,
                    1.0,1.0,1.0,1.0,0.0,1.0,1.0};

GLubyte cubeIndices[]={0,3,2,1,2,3,7,6,0,4,7,3,1,2,6,5,4, 5,6,7,0,1,5,4};
static GLfloat theta[]={0.0,0.0,0.0};
static GLint axis=2;

void display(void)
{
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  glRotatef(theta[0],1.0,0.0,0.0);
  glRotatef(theta[1],0.0,1.0,0.0);
  glRotatef(theta[2],0.0,0.0,1.0);
  glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE, cubeIndices);
  glFlush();
  glutSwapBuffers();
}

void spinCube()
{
    theta[axis]+=2.0;
    if(theta[axis]>360.0) theta[axis]-=360.0;
        glutPostRedisplay();
}

void mouse(int btn, int state, int x, int y)
{
    if(btn==GLUT_LEFT_BUTTON && state==GLUT_DOWN)
        axis=0;
    if(btn==GLUT_MIDDLE_BUTTON&&state==GLUT_DOWN)
        axis=1;
    if(btn==GLUT_RIGHT_BUTTON&& state==GLUT_DOWN)
        axis=2;
}

void myReshape(int w, int h)
{
    glViewport(0,0,w,h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if(w<=h)
        glOrtho(-2.0,2.0,-2.0*(GLfloat)h/(GLfloat)w, 2.0*(GLfloat)h/(GLfloat)w,-10.0,10.0);
    else
        glOrtho(-2.0*(GLfloat)w/(GLfloat)h, 2.0*(GLfloat)w/(GLfloat)h, -2.0,2.0,-10.0,10.0);
    glMatrixMode(GL_MODELVIEW);
}

void main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    glutInitWindowSize(500,500);
    glutCreateWindow("Spin a color cube");
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glutIdleFunc(spinCube);
    glutMouseFunc(mouse);
    glEnable(GL_DEPTH_TEST);    
    glEnableClientState(GL_COLOR_ARRAY);
    glEnableClientState(GL_VERTEX_ARRAY);
    glVertexPointer(3,GL_FLOAT, 0, vertices);
    glColorPointer(3, GL_FLOAT, 0, colors);
    glColor3f(1.0,1.0,1.0);
    glutMainLoop();
}

cg4
#include <stdlib.h>
#include <GL/glut.h>
#include <stdio.h>

GLfloat vertices[ ]={  -1.0,-1.0,-1.0,
                        1.0,-1.0,-1.0,
                        1.0, 1.0,-1.0,
                       -1.0, 1.0,-1.0,
                       -1.0,-1.0, 1.0,
                        1.0,-1.0, 1.0,
                        1.0, 1.0, 1.0,
                       -1.0, 1.0, 1.0 };

GLfloat normals[ ] ={  -1.0,-1.0,-1.0,
                        1.0,-1.0,-1.0,
                        1.0, 1.0,-1.0,
                       -1.0, 1.0,-1.0,
                       -1.0,-1.0, 1.0,
                        1.0,-1.0, 1.0,
                        1.0, 1.0, 1.0,
                       -1.0, 1.0, 1.0 };

GLfloat colors[ ]={ 0.0, 0.0, 0.0,
                    1.0, 0.0, 0.0,
                    1.0, 1.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0,
                    1.0, 0.0, 1.0,
                    1.0, 1.0, 1.0,
                    0.0, 1.0, 1.0};

GLubyte cubeIndices[]={ 0,3,2,1,
                        2,3,7,6,
                        0,4,7,3,
                        1,2,6,5,
                        4,5,6,7,
                        0,1,5,4};

static GLfloat theta[] = {0.0,0.0,0.0};
static GLint axis = 2;
static GLdouble viewer[] = {0.0,0.0,5.0};

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    gluLookAt(viewer[0],viewer[1],viewer[2],0.0,0.0,0.0,0.0,1.0,0.0);
    glRotatef(theta[0],1.0,0.0,0.0);
    glRotatef(theta[1],0.0,1.0,0.0);
    glRotatef(theta[2],0.0,0.0,1.0);
    glDrawElements(GL_QUADS,24,GL_UNSIGNED_BYTE,cubeIndices);
    glFlush();
    glutSwapBuffers();
}

void mouse(int btn, int state, int x, int y)
{
    if(btn==GLUT_LEFT_BUTTON && state==GLUT_DOWN)
        axis=0;
    if(btn==GLUT_RIGHT_BUTTON && state==GLUT_DOWN)
        axis=1;
    if(btn==GLUT_MIDDLE_BUTTON && state==GLUT_DOWN)
        axis=2;
    theta[axis]+=2.0;
    
    if(theta[axis]>360.0)
        theta[axis]-=360.0;
    glutPostRedisplay();
}

void keys(unsigned char key, int x, int y)
{
    if(key=='x') viewer[0]-=1.0;
    if(key=='X') viewer[0]+=1.0;
    if(key=='y') viewer[1]-=1.0;
    if(key=='Y') viewer[1]+=1.0;
    if(key=='z') viewer[2]-=1.0;
    if(key=='Z') viewer[2]+=1.0;
    glutPostRedisplay();
}

void myReshape(int w, int h)
{
    glViewport(0,0,w,h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if(w<=h)
        glFrustum(-2.0,2.0,-2.0*(GLfloat)h/(GLfloat)w,2.0*(GLfloat)h/(GLfloat)w,2.0,20.0);
    else
        glFrustum(-2.0,2.0,-2.0*(GLfloat)w/(GLfloat)h,2.0*(GLfloat)w/(GLfloat)h,2.0,20.0);
    glMatrixMode(GL_MODELVIEW);
}

int main(int argc, char **argv)
{
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB|GLUT_DEPTH);
    glutInitWindowSize(500,500);
    glutCreateWindow("color cuce");
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glutKeyboardFunc(keys);
    glutMouseFunc(mouse);
    glEnable(GL_DEPTH_TEST);
    glEnableClientState(GL_COLOR_ARRAY);
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glVertexPointer(3,GL_FLOAT,0,vertices);
    glColorPointer(3,GL_FLOAT,0,colors);
    glNormalPointer(GL_FLOAT,0,normals);
    glColor3f(1.0,1.0,1.0);
    glutMainLoop();
}

cg5
#include<stdio.h>
#include<GL/glut.h>
#define outcode int
#include<stdbool.h>
double xmin=50,ymin=50,xmax=100,ymax=100;
double xvmin=200,yvmin=200,xvmax=300,yvmax=300;
double x0,y2,x1,y3;
const int RIGHT=8;
const int LEFT=2;
const int TOP=4;
const int BOTTOM=1;
outcode ComputeOutCode(double x, double y);

void CohenSutherland(double x0, double y0, double x1, double y1)
{
    outcode outcode0, outcode1, outcodeOut;
    bool accept=false, done=false;
    outcode0=ComputeOutCode(x0,y0);
    outcode1=ComputeOutCode(x1,y3);
    do
    {
        if(!(outcode0 | outcode1))
        {
            accept=true;
            done=true;
        }
        else if(outcode0 & outcode1)
            done=true;
        else
        {
            double x, y;
            outcodeOut=outcode0?outcode0:outcode1;
            if(outcodeOut & TOP)
            {
                x=x0+(x1-x0)*(ymax-y2)/(y3-y2);
                y=ymax;
            }
            else if(outcodeOut & BOTTOM)
            {
                x=x0+(x1-x0)*(ymin-y2)/(y3-y2);
                y=ymin;
            }
            else if(outcodeOut & RIGHT)
            {
                y=y2+(y3-y2)*(xmax-x0)/(x1-x0);
                x=xmax;
            }
            else
            {
                y=y2+(y3-y2)*(xmin-x0)/(x1-x0);
                x=xmin;
            }
            if(outcodeOut==outcode0)
            {
                x0=x;
                y2=y;
                outcode0=ComputeOutCode(x0,y2);
            }
            else
            {
                x1=x;
                y3=y;
                outcode1=ComputeOutCode(x1,y3);
            }
        }
    }while(!done);
    
    if(accept)
    {
        double sx=(xvmax-xvmin)/(xmax-xmin);
        double sy=(yvmax-yvmin)/(ymax-ymin);
        double vx0=xvmin+(x0-xmin)*sx;
        double vy2=yvmin+(y2-ymin)*sy;
        double vx1=xvmin+(x1-xmin)*sx;
        double vy3=yvmin+(y3-ymin)*sy;
        glColor3f(1.0,0.0,0.0);
        glBegin(GL_LINE_LOOP);
            glVertex2f(xvmin, yvmin);
            glVertex2f(xvmax, yvmin);
            glVertex2f(xvmax, yvmax);
            glVertex2f(xvmin, yvmax);
        glEnd();
        glColor3f(0.0,0.0,1.0);
        glBegin(GL_LINES);
            glVertex2d(vx0,vy2);
            glVertex2d(vx1,vy3);
        glEnd();
    }
}

outcode ComputeOutCode(double x, double y)
{
    outcode code=0;
    if(y > ymax)
        code = TOP;
    else if(y < ymin)
        code = BOTTOM;
    if(x > xmax)
        code = RIGHT;
    else if(x < xmin)
        code = LEFT;
    return code;
}

void display()
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1.0,0.0,0.0);
    glBegin(GL_LINES);
        glVertex2d(x0,y2);
        glVertex2d(x1,y3);
    glEnd();
    glColor3f(0.0,0.0,1.0);
    glBegin(GL_LINE_LOOP);
        glVertex2f(xmin, ymin);
        glVertex2f(xmax, ymin);
        glVertex2f(xmax, ymax);
        glVertex2f(xmin, ymax);
    glEnd();
    CohenSutherland(x0,y2,x1,y3);
    glFlush();
}

void myinit()
{
    glClearColor(1.0,1.0,1.0,1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0,499.0,0.0,499.0);
}

void main(int argc, char** argv)
{
    printf("Enter the end points of the line: ");
    scanf("%lf%lf%lf%lf", &x0,&y2,&x1,&y3);
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(500,500);
    glutInitWindowPosition(0,0);
    glutCreateWindow("Cohen-Sutherland Line Clipping");
    glutDisplayFunc(display);
    myinit();
    glutMainLoop();
}

cg6
#include<GL/glut.h>
void wall(double thickness)
{
    glPushMatrix();
    glTranslated(0.5,0.5*thickness, 0.5);
    glScaled(1.0,thickness, 1.0);
    glutSolidCube(1.0);
    glPopMatrix();
}

void tableleg(double thick, double len)
{
    glPushMatrix();
    glTranslated(0,len/2,0);
    glScaled(thick, len, thick);
    glutSolidCube(1.0);
    glPopMatrix();
}

void table(double topwid, double topthick, double legthick, double leglen)
{
    glPushMatrix();
    glTranslated(0,leglen,0);
    glScaled(topwid, topthick, topwid);
    glutSolidCube(1.0);
    glPopMatrix();
    double dist=0.95*topwid/2.0-legthick/2.0;
    glPushMatrix();
    glTranslated(dist, 0, dist);
    tableleg(legthick, leglen);
    glTranslated(0.0,0.0,-2*dist);
    tableleg(legthick, leglen);
    glTranslated(-2*dist, 0, 2*dist);
    tableleg(legthick, leglen);
    glTranslated(0,0,-2*dist);
    tableleg(legthick,leglen);
    glPopMatrix();
}

void displaySolid(void)
{
    GLfloat mat_ambient[]={0.7f,0.7f,0.7f,1.0f};
    GLfloat mat_diffuse[]={0.5f,0.5f,0.5f,1.0f};
    GLfloat mat_specular[]={1.0f,1.0f,1.0f,1.0f};
    GLfloat mat_shininess[]={50.0f};
    glMaterialfv(GL_FRONT,GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT,GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT,GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT,GL_SHININESS, mat_shininess);

    GLfloat lightintensity[]={0.7f,0.7f,0.7f,1.0f};
    GLfloat lightposition[]={2.0f,6.0f,3.0f,0.0f};
    glLightfv(GL_LIGHT0, GL_POSITION, lightposition);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightintensity);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    double winht=1.0;
    glOrtho(-winht*64/48, winht*64/48, -winht, winht,  
                                          0.1, 100.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(2.3,1.3,2.0,0.0,0.25,0.0,0.0,1.0,0.0);
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
      glTranslated(0.6,0.38,0.5);
      glRotated(30,0,1,0);
      glutSolidTeapot(0.08);
    glPopMatrix();
    glPushMatrix();
      glTranslated(0.4,0,0.4);
      table(0.6,0.02,0.02,0.3);
    glPopMatrix();
    wall(0.02);
    glPushMatrix();
      glRotated(90.0,0.0,0.0,1.0);
      wall(0.02);
    glPopMatrix();
    glPushMatrix();
      glRotated(-90.0,1.0,0.0,0.0);
      wall(0.02);
    glPopMatrix();
    glFlush();
}


void main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB|GLUT_DEPTH);
    glutInitWindowPosition(50,50);
    glutInitWindowSize(400,300);
    glutCreateWindow("Shaded Scene");
    glutDisplayFunc(displaySolid);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glShadeModel(GL_SMOOTH);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    glClearColor(0.1,0.1,0.1,0.0);
    glViewport(0,0,640,480);
    glutMainLoop();
}

cg7
#include <stdlib.h>
#include <stdio.h>
#include <GL/glut.h>

typedef float point[3];
point v[]={ {0.0, 0.0, 1.0},
            {0.0, 0.942809, -0.33333}, 
            {-0.816497, -0.471405, -0.333333},
            {0.816497, -0.471405, -0.333333}};
static GLfloat theta[] = {0.0,0.0,0.0};
int n;

void triangle( point a, point b, point c)
{
    glBegin(GL_POLYGON);
    glNormal3fv(a);
    glVertex3fv(a);
    glVertex3fv(b);
    glVertex3fv(c);
    glEnd();
}

void divide_triangle(point a, point b, point c, int m)
{
    point v1, v2, v3;
    int j;
    if(m>0)
    {
        for(j=0; j<3; j++)
            v1[j]=(a[j]+b[j])/2;
        for(j=0; j<3; j++)
            v2[j]=(a[j]+c[j])/2;
        for(j=0; j<3; j++)
            v3[j]=(b[j]+c[j])/2;
        divide_triangle(a, v1, v2, m-1);
        divide_triangle(c, v2, v3, m-1);
        divide_triangle(b, v3, v1, m-1);
    }
    else(triangle(a,b,c));
}

void tetrahedron( int m)
{
    glColor3f(1.0,0.0,0.0);
    divide_triangle(v[0], v[1], v[2], m);
    glColor3f(0.0,1.0,0.0);
    divide_triangle(v[3], v[2], v[1], m);
    glColor3f(0.0,0.0,1.0);
    divide_triangle(v[0], v[3], v[1], m);
    glColor3f(0.0,0.0,0.0);
    divide_triangle(v[0], v[2], v[3], m);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    tetrahedron(n);
    glFlush();
}

void myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w, 2.0 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
    else
        glOrtho(-2.0 * (GLfloat) w / (GLfloat) h, 2.0 * (GLfloat) w / (GLfloat) h, -2.0, 2.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glutPostRedisplay();
}

void main(int argc, char **argv)
{
    printf(" No. of Divisions ? ");
    scanf("%d",&n);
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutCreateWindow("3D Gasket");
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glEnable(GL_DEPTH_TEST);
    glClearColor (1.0, 1.0, 1.0, 1.0);
    glutMainLoop();
}

cg8
#include<GL/glut.h>
#include<math.h>
#include<stdio.h>

void bezierCoefficients(int n,int *c)
{
    int k,i;
    for(k=0;k<=n;k++)
    {
        c[k]=1;
        for(i=n;i>=k+1;i--)
            c[k]*=i;
        for(i=n-k;i>=2;i--)
            c[k]/=i;
    }
}

void display()
{
    int cp[4][2]={{10,10},{100,200},{200,50},{300,300}};
    int c[4],k,n=3;
    float x,y,u,blend;
    bezierCoefficients(n,c);
    glClear(GL_COLOR_BUFFER_BIT);
        glColor3f(1.0,0.0,0.0);
        glLineWidth(5.0);
    glBegin(GL_LINE_STRIP);
        for(u=0;u<1.0;u+=0.01)
        {
            x=0;y=0;
            for(k=0;k<4;k++)
            {
                blend=c[k]*pow(u,k)*pow(1-u,n-k);
                x+=cp[k][0]*blend;
                y+=cp[k][1]*blend;
            }
        glVertex2f(x,y);
        }
    glEnd();
    glFlush();
}

void myinit()
{
    glClearColor(1.0,1.0,1.0,1.0);
    glColor3f(1.0,0.0,0.0);
    glPointSize(5.0);
    gluOrtho2D(0.0,600,0.0,600.0);
}

int main(int argc, char ** argv)
{
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(600,600);
    glutCreateWindow("Bezier Curve");
    glutDisplayFunc(display);
    myinit();
    glutMainLoop();
    return 0;
}

cg9
#include <stdlib.h>
#include <stdio.h>
#include <GL/glut.h>
float x1,x2,x3,x4,y0,y2,y3,y4;

void edgedetect(float x1,float y0,float x2,float y2,int *le,int *re)
{
    float mx,x,temp;
    int i;
    if((y2-y0)<0)
    {
        temp=y0;y0=y2;y2=temp;
        temp=x1;x1=x2;x2=temp;
    }
    if((y2-y0)!=0)
        mx=(x2-x1)/(y2-y0);
    else
        mx=x2-x1;
        x=x1;
    for(i=y0;i<=y2;i++)
    {
        if(x<(float)le[i])
            le[i]=(int)x;
        if(x>(float)re[i])
            re[i]=(int)x;
        x+=mx;
    }
}

void draw_pixel(int x,int y)
{
    glColor3f(1.0,1.0,0.0);
    glBegin(GL_POINTS);
    glVertex2i(x,y);
    glEnd();
}

void scanfill(float x1,float y0,float x2,float y2,float x3,float y3,float x4,float y4)
{
    int le[500],re[500];
    int i,y;
    for(i=0;i<500;i++)
    {
        le[i]=500;
        re[i]=0;
    }
    edgedetect(x1,y0,x2,y2,le,re);
    edgedetect(x2,y2,x3,y3,le,re);
    edgedetect(x3,y3,x4,y4,le,re);
    edgedetect(x4,y4,x1,y0,le,re);
    for(y=0;y<500;y++)
    {
        if(le[y]<=re[y])
            for(i=(int)le[y];i<(int)re[y];i++)
                draw_pixel(i,y);
    }
}

void display()
{
    x1=200.0;y0=200.0;x2=100.0;y2=300.0;x3=200.0;y3=400.0;x4=300.0;y4=300.0;
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(0.0, 0.0, 1.0);
    glBegin(GL_LINE_LOOP);
        glVertex2f(x1,y0);
        glVertex2f(x2,y2);
        glVertex2f(x3,y3);
        glVertex2f(x4,y4);
    glEnd();
    scanfill(x1,y0,x2,y2,x3,y3,x4,y4);
    glFlush();
}

void myinit()
{
    glClearColor(1.0,1.0,1.0,1.0);
    glColor3f(1.0,0.0,0.0);
    glPointSize(1.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0,499.0,0.0,499.0);
}

int main(int argc, char** argv)
{
    glutInit(&argc,argv);
    glutInitDisplayMode(GLUT_SINGLE|GLUT_RGB);
    glutInitWindowSize(500,500);
    glutInitWindowPosition(0,0);
    glutCreateWindow("Filling a Polygon using Scan-line Algorithm");
    glutDisplayFunc(display);
    myinit();
    glutMainLoop();
}
    </textarea>